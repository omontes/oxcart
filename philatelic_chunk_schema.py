"""
Philatelic Chunk Schema - Complete Structure Documentation

This module provides comprehensive type definitions and schema documentation for
OXCART philatelic chunks as processed by dolphin_transformer.py and enriched
by philatelic_patterns.py Advanced Philatelic Research System v3.0.

VERSION: 1.0 - Complete Philatelic Chunk Schema
AUTHOR: Generated by Claude Code for OXCART RAG Project
LAST UPDATE: 2025-08-22

This schema documents all possible fields that can appear in a philatelic chunk
after complete processing through the pipeline:
1. Dolphin parsing -> OXCART format (dolphin_transformer.py)
2. Philatelic enrichment (philatelic_patterns.py enrich_chunk_advanced_philatelic)
"""

from typing import Dict, Any, Optional, List, Union, TypedDict, Literal
from dataclasses import dataclass, field
from datetime import datetime


# ============================================================================
# CORE TYPES AND LITERALS
# ============================================================================

ChunkType = Literal[
    "text", "title", "section", "subsection", "table", "figure", "caption", 
    "marginalia", "header", "table_row", "decree", "auction_result", "issue_notice"
]

CatalogSystem = Literal["Scott", "Michel", "Yvert", "Zumstein", "Gibbons", "M", "A"]
Currency = Literal["USD", "CRC", "CENT"]
PerfMethods = Literal["imperforate", "pin perf", "line perf", "comb perf", "harrow perf", "roulette", "serpentine die cut"]
PaperTypes = Literal["wove paper", "laid paper", "granite paper", "pelure paper", "manila paper", "safety paper"]
PrintingMethods = Literal["lithography", "engraved", "intaglio", "offset", "photogravure", "typography", "letterpress"]
GumTypes = Literal["original gum", "tropical gum", "white gum", "yellow gum", "no gum", "regummed"]
MintStatus = Literal["mint never hinged", "mint lightly hinged", "mint hinged", "mint no gum"]
UsedStatus = Literal["used", "cancelled to order", "first day cancel", "postally used", "commercially used"]
Centering = Literal["perfectly centered", "superb", "extremely fine", "very fine", "fine", "very good", "good", "poor"]
EFOClass = Literal["overprint", "color_error", "mirror_print"]
EFOSubtype = Literal["inverted", "double", "color_shift", "missing_color", "wrong_color", "mirror", "reversed"]


# ============================================================================
# BOUNDING BOX AND GROUNDING
# ============================================================================

class BoundingBox(TypedDict, total=False):
    """
    Normalized bounding box coordinates (0.0 to 1.0).
    
    Generated by dolphin_transformer._normalize_box() from original bbox
    coordinates and page dimensions.
    
    Example:
        {"l": 0.1234, "t": 0.0567, "r": 0.8901, "b": 0.2345}
    """
    l: float  # Left coordinate (0.0 to 1.0)
    t: float  # Top coordinate (0.0 to 1.0)  
    r: float  # Right coordinate (0.0 to 1.0)
    b: float  # Bottom coordinate (0.0 to 1.0)


class GroundingInfo(TypedDict, total=False):
    """
    Grounding information linking chunk to specific page and location.
    
    Generated by dolphin_transformer.transform_dolphin_to_oxcart_preserving_labels()
    during the transformation from Dolphin format to OXCART.
    
    Example:
        {"page": 5, "box": {"l": 0.123, "t": 0.456, "r": 0.789, "b": 0.890}}
    """
    page: int                      # Page number (1-indexed)
    box: Optional[BoundingBox]     # Normalized bounding box (may be null if bbox extraction failed)


# ============================================================================
# CATALOG AND IDENTIFICATION
# ============================================================================

class CatalogEntry(TypedDict):
    """
    Philatelic catalog identification entry.
    
    Extracted by philatelic_patterns.extract_all_catalog_numbers() using
    various regex patterns (RX_SCOTT, RX_MICHEL, RX_YVERT, etc.).
    
    Examples:
        {"system": "Scott", "number": "147"}
        {"system": "Michel", "number": "23a"} 
        {"system": "Yvert", "number": "45-50"}
        {"system": "A", "number": "21"}  # Legacy Costa Rica catalog
    """
    system: CatalogSystem  # Catalog system identifier
    number: str           # Catalog number (may include ranges like "45-50", variants like "23a")


class PostageValue(TypedDict):
    """
    Face value denomination information.
    
    Extracted by RX_POSTAGE_VAL pattern from philatelic_patterns.py
    detecting values like "5 centavos", "10 c", "1 peso", etc.
    
    Examples:
        {"face_value": 5.0, "unit": "centavos"}
        {"face_value": 10.0, "unit": "c"}
        {"face_value": 0.5, "unit": "colones"}
    """
    face_value: float  # Numeric value 
    unit: str         # Unit designation (centavos, colones, c, cts, etc.)


class PriceInfo(TypedDict):
    """
    Price/value information with currency detection.
    
    Extracted by RX_PRICE pattern and normalized by _norm_price() function
    from philatelic_patterns.py.
    
    Examples:
        {"amount": 15.50, "currency": "USD", "raw": "$15.50"}
        {"amount": 2500.0, "currency": "CRC", "raw": "â‚¡2,500"}
        {"amount": 25.0, "currency": "CENT", "raw": "25 centimos"}
    """
    amount: float     # Numeric amount
    currency: Currency # Standardized currency code
    raw: str          # Original text string


# ============================================================================
# TECHNICAL SPECIFICATIONS
# ============================================================================

class PerforationInfo(TypedDict, total=False):
    """
    Perforation specifications.
    
    Extracted by extract_technical_specs() using RX_PERF_MEASURE,
    RX_IMPERF, and RX_PERF_TYPES patterns.
    
    Examples:
        {"measurements": ["12"], "type": "imperforate"}
        {"measurements": ["11.5", "12x11.5"], "method": "comb perf"}
    """
    measurements: List[str]           # Gauge measurements (e.g., ["12", "11.5x12"])
    type: Optional[str]              # "imperforate" if imperf detected
    method: Optional[PerfMethods]    # Perforation method


class PaperInfo(TypedDict, total=False):
    """
    Paper type and characteristics.
    
    Extracted by extract_technical_specs() using RX_PAPER_TYPES 
    and RX_PAPER_THICKNESS patterns.
    
    Examples:
        {"type": "wove paper", "thickness": "thick"}
        {"type": "laid paper"}
    """
    type: Optional[PaperTypes]    # Paper type
    thickness: Optional[str]      # Thickness (thick/thin/medium)


class WatermarkInfo(TypedDict, total=False):
    """
    Watermark information.
    
    Extracted by extract_technical_specs() using RX_WATERMARK_TYPES
    and RX_WATERMARK_POSITION patterns.
    
    Examples:
        {"type": "multiple crown", "position": "inverted"}
        {"type": "script ca", "position": "normal"}
    """
    type: Optional[str]       # Watermark type description
    position: Optional[str]   # Position/orientation (inverted/sideways/normal)


class PrintingInfo(TypedDict):
    """
    Printing method information.
    
    Extracted by extract_technical_specs() using RX_PRINTING_METHODS pattern.
    
    Examples:
        {"method": "lithographed"}
        {"method": "engraved"}
    """
    method: PrintingMethods   # Printing technique


class GumInfo(TypedDict):
    """
    Gum type and condition.
    
    Extracted by extract_technical_specs() using RX_GUM_TYPES pattern.
    
    Examples:
        {"type": "original gum"}
        {"type": "no gum"}
    """
    type: GumTypes   # Gum type/condition


# ============================================================================
# CONDITION ASSESSMENT
# ============================================================================

class ConditionInfo(TypedDict, total=False):
    """
    Comprehensive condition assessment.
    
    Extracted by extract_condition_assessment() using various condition
    patterns (RX_CONDITION_MINT, RX_CONDITION_USED, RX_CENTERING, RX_DEFECTS).
    
    Examples:
        {"mint_status": "mint never hinged", "centering": "very fine"}
        {"used_status": "postally used", "centering": "fine", "defects": ["thin", "crease"]}
    """
    mint_status: Optional[MintStatus]    # Mint condition designation
    used_status: Optional[UsedStatus]    # Used condition designation  
    centering: Optional[Centering]       # Centering grade
    defects: Optional[List[str]]         # List of defects (thin, tear, stain, etc.)


# ============================================================================
# EFO (ERRORS, FREAKS & ODDITIES) CLASSIFICATION
# ============================================================================

class EFOVariety(TypedDict, total=False):
    """
    Error, Freak & Oddity classification.
    
    Extracted by classify_efo_varieties() using various EFO patterns
    (RX_OVERPRINT_INVERTED, RX_COLOR_ERROR, RX_MIRROR, etc.).
    
    Examples:
        {
            "efo_class": "overprint",
            "subtype": "inverted", 
            "label": "sobrecarga invertida",
            "text": "GUANACASTE",
            "confidence": 0.8
        }
        {
            "efo_class": "color_error",
            "subtype": "missing_color",
            "label": "error de color", 
            "confidence": 0.7
        }
    """
    efo_class: EFOClass          # Main EFO classification
    subtype: EFOSubtype          # Specific subtype
    label: str                   # Human-readable label (often Spanish)
    text: Optional[str]          # Specific text involved (for overprints)
    confidence: float            # Confidence score (0.0 to 1.0)


# ============================================================================
# COSTA RICA SPECIFIC CONTEXT
# ============================================================================

class CostaRicaContext(TypedDict, total=False):
    """
    Costa Rica specific philatelic context.
    
    Extracted by classify_costa_rica_context() using CR-specific patterns
    (RX_GUANACASTE_OVERPRINT, RX_CR_PERIODS, RX_CR_PERSONALITIES, RX_CR_GEOGRAPHY).
    
    Examples:
        {
            "guanacaste_period": true,
            "historical_significance": "1885-1891 Guanacaste overprint period",
            "personalities": ["jesÃºs jimÃ©nez"],
            "geographic_features": ["volcÃ¡n arenal"]
        }
    """
    guanacaste_period: Optional[bool]           # True if Guanacaste overprint period
    historical_significance: Optional[str]      # Historical context description
    historical_periods: Optional[List[str]]     # Historical periods mentioned
    personalities: Optional[List[str]]          # Costa Rican personalities
    geographic_features: Optional[List[str]]    # Geographic features


# ============================================================================
# TOPICS AND CLASSIFICATION
# ============================================================================

class TopicsInfo(TypedDict, total=False):
    """
    Topic classification and tagging.
    
    Generated by enrich_chunk_advanced_philatelic() using TOPIC_PATTERNS
    and enhanced with confidence scoring and tags.
    
    Examples:
        {
            "primary": "fauna_cr",
            "secondary": ["aviacion", "historia_postal"],
            "tags": ["error", "variety", "watermark"],
            "confidence": 0.75
        }
    """
    primary: Optional[str]       # Primary topic classification
    secondary: List[str]        # Secondary topics
    tags: List[str]            # Enhanced tags (triangular, imperforate, proof, etc.)
    confidence: float          # Quality/confidence score


class AxesInfo(TypedDict, total=False):
    """
    Classification axes for filtering and organization.
    
    Generated by enrich_chunk_advanced_philatelic() using TYPE_PATTERNS
    and date-based period classification.
    
    Examples:
        {
            "type": ["airmail", "commemorative"],
            "period": ["1920s", "1930s"]
        }
    """
    type: List[str]      # Stamp types (airmail, postage_due, official, etc.)
    period: List[str]    # Temporal periods (decades like "1920s", "1950s")


# ============================================================================
# COMPLETE ENTITIES STRUCTURE
# ============================================================================

class PhilatelicEntities(TypedDict, total=False):
    """
    Complete philatelic entities extracted from chunk text.
    
    This is the main entities container populated by 
    enrich_chunk_advanced_philatelic() function, containing all
    possible philatelic metadata that can be extracted.
    
    Example:
        {
            "catalog": [{"system": "Scott", "number": "147"}],
            "dates": ["1963-05-15", "1963"],
            "prices": [{"amount": 25.0, "currency": "USD", "raw": "$25"}],
            "values": [{"face_value": 5.0, "unit": "centavos"}],
            "colors": ["blue", "red"],
            "designs": ["coat of arms", "cathedral"],
            "perforation": {"measurements": ["12"]},
            "paper": {"type": "wove paper"},
            "printing": {"method": "lithographed"},
            "watermark": {"type": "multiple crown"},
            "gum": {"type": "original gum"},
            "condition": {"mint_status": "mint never hinged", "centering": "very fine"},
            "varieties": [{"class": "overprint", "subtype": "inverted", "label": "sobrecarga invertida", "confidence": 0.8}],
            "costa_rica_context": {"guanacaste_period": true}
        }
    """
    # Catalog identifications
    catalog: List[CatalogEntry]
    
    # Temporal information
    dates: List[str]                    # ISO date strings (YYYY-MM-DD or YYYY)
    
    # Economic information
    prices: List[PriceInfo]             # Market prices, auction results
    values: List[PostageValue]          # Face value denominations
    
    # Appearance
    colors: List[str]                   # Colors mentioned
    designs: List[str]                  # Design subjects
    
    # Technical specifications
    perforation: PerforationInfo        # Perforation details
    paper: PaperInfo                   # Paper type and thickness
    printing: PrintingInfo             # Printing method
    watermark: WatermarkInfo           # Watermark information
    gum: GumInfo                       # Gum type and condition
    
    # Condition assessment
    condition: ConditionInfo            # Overall condition assessment
    
    # Varieties and errors
    varieties: List[EFOVariety]         # Errors, freaks & oddities
    
    # Regional context
    costa_rica_context: CostaRicaContext  # Costa Rica specific information


# ============================================================================
# METADATA STRUCTURE
# ============================================================================

class ChunkMetadata(TypedDict, total=False):
    """
    Complete chunk metadata structure.
    
    This combines the basic metadata from dolphin_transformer.py with
    the advanced philatelic enrichment from philatelic_patterns.py.
    
    Generated and populated by:
    1. transform_dolphin_to_oxcart_preserving_labels() - basic metadata
    2. enrich_chunk_advanced_philatelic() - philatelic enrichment
    
    Example:
        {
            "labels": ["para"],
            "reading_order_range": [5, 5],
            "part_index": null,
            "quality_score": 0.75,
            "entities": {...},  # PhilatelicEntities
            "topics": {...},    # TopicsInfo
            "axes": {...}       # AxesInfo
        }
    """
    # Basic metadata (from dolphin_transformer.py)
    labels: List[str]                    # Original Dolphin labels
    reading_order_range: List[int]       # Reading order range [start, end]
    part_index: Optional[int]            # Part index for split chunks
    quality_score: float                 # Simple quality metric
    
    # Table-specific metadata (for table/table_row chunks)
    table_html: Optional[str]            # Original HTML table
    table_markdown: Optional[str]        # Markdown representation
    table_tsv: Optional[str]             # TSV representation  
    headers: Optional[List[str]]         # Table headers
    n_rows: Optional[int]               # Number of rows
    parent_table_chunk_id: Optional[str] # Parent table ID (for table_row chunks)
    row_index_range: Optional[List[int]] # Row range for table_row chunks
    
    # Figure-specific metadata
    figure_path: Optional[str]           # Path to extracted figure
    
    # Grouping metadata (from chunk optimization)
    combined_chunks: Optional[int]       # Number of chunks combined
    
    # Philatelic enrichment (from philatelic_patterns.py)
    entities: PhilatelicEntities         # All extracted entities
    topics: TopicsInfo                  # Topic classification
    axes: Optional[AxesInfo]            # Classification axes


# ============================================================================
# COMPLETE CHUNK STRUCTURE
# ============================================================================

class PhilatelicChunk(TypedDict):
    """
    Complete OXCART philatelic chunk structure.
    
    This is the final structure of each chunk in the OXCART JSON after
    complete processing through dolphin_transformer.py and philatelic_patterns.py.
    
    Generated by:
    1. transform_dolphin_to_oxcart_preserving_labels() - base structure
    2. enrich_chunk_advanced_philatelic() - philatelic metadata
    3. Optional chunk optimization for improved RAG performance
    
    Example:
        {
            "chunk_id": "OXCART30:005:12-12:0",
            "chunk_type": "text",
            "text": "Scott 147, 5 centavos blue, mint never hinged, very fine centering",
            "grounding": [{"page": 5, "box": {"l": 0.123, "t": 0.456, "r": 0.789, "b": 0.890}}],
            "metadata": {
                "labels": ["para"],
                "reading_order_range": [12, 12],
                "quality_score": 0.85,
                "entities": {
                    "catalog": [{"system": "Scott", "number": "147"}],
                    "values": [{"face_value": 5.0, "unit": "centavos"}],
                    "colors": ["blue"],
                    "condition": {"mint_status": "mint never hinged", "centering": "very fine"}
                },
                "topics": {"primary": "definitive", "confidence": 0.85}
            }
        }
    """
    # Core identification
    chunk_id: str                       # Unique chunk identifier (doc_id:page:reading_order:part)
    chunk_type: ChunkType              # Type classification
    text: str                          # Extracted text content
    
    # Location and grounding
    grounding: List[GroundingInfo]     # Page and bounding box information
    
    # Complete metadata
    metadata: ChunkMetadata            # All metadata including philatelic enrichment


# ============================================================================
# DOCUMENT-LEVEL STRUCTURE
# ============================================================================

class ExtractionMetadata(TypedDict, total=False):
    """
    Document-level extraction metadata.
    
    Generated by _validate_and_enhance_chunks() and enrich_all_chunks_advanced_philatelic().
    
    Example:
        {
            "chunk_count": 150,
            "total_text_length": 45000,
            "avg_chunk_length": 300.0,
            "max_chunk_length": 1200,
            "min_chunk_length": 15,
            "chunk_types": {"text": 120, "table": 15, "figure": 10, "caption": 5},
            "quality_issues": 3,
            "validation_applied": true,
            "enrichment_version": "philately-advanced-v3.0",
            "enriched_at": "2025-08-22T10:30:45.123456Z",
            "features": ["international_catalogs", "technical_specs", "efo_classification"]
        }
    """
    # Quantitative metrics
    chunk_count: int                    # Total number of chunks
    total_text_length: int             # Total characters across all chunks
    avg_chunk_length: float            # Average chunk length
    max_chunk_length: int              # Maximum chunk length
    min_chunk_length: int              # Minimum chunk length
    
    # Type distribution
    chunk_types: Dict[str, int]        # Count by chunk type
    
    # Quality metrics
    quality_issues: int                # Number of potential quality issues
    validation_applied: bool           # Whether validation was applied
    
    # Enrichment information
    enrichment_version: str            # Philatelic enrichment version
    enriched_at: str                   # ISO timestamp of enrichment
    features: List[str]                # List of applied enrichment features


class PhilatelicDocument(TypedDict):
    """
    Complete OXCART philatelic document structure.
    
    This is the final JSON structure produced by the complete pipeline
    for a philatelic document.
    
    Example:
        {
            "doc_id": "OXCART30", 
            "source": "dolphin",
            "page_count": 28,
            "extraction_date": "2025-08-22T10:30:45.123456Z",
            "metadata": {"title": "", "author": "", "language": "und"},
            "chunks": [...],  # List of PhilatelicChunk
            "markdown": "# Document content as markdown...",
            "extraction_metadata": {...}  # ExtractionMetadata
        }
    """
    # Document identification
    doc_id: str                        # Document identifier
    source: str                        # Source system ("dolphin")
    page_count: int                    # Number of pages
    extraction_date: str               # ISO timestamp of extraction
    
    # Basic document metadata
    metadata: Dict[str, str]           # Title, author, language
    
    # Content
    chunks: List[PhilatelicChunk]      # All document chunks
    markdown: str                      # Complete markdown representation
    
    # Processing metadata
    extraction_metadata: ExtractionMetadata  # Document-level metadata


# ============================================================================
# VALIDATION AND UTILITY FUNCTIONS
# ============================================================================

def validate_chunk_structure(chunk: Dict[str, Any]) -> bool:
    """
    Validate that a chunk conforms to the expected structure.
    
    Args:
        chunk: Dictionary representing a chunk
        
    Returns:
        True if structure is valid, False otherwise
        
    Example:
        >>> chunk = {"chunk_id": "test:001:1-1:0", "chunk_type": "text", "text": "sample"}
        >>> validate_chunk_structure(chunk)
        True
    """
    required_fields = ["chunk_id", "chunk_type", "text", "grounding", "metadata"]
    
    # Check required top-level fields
    for field in required_fields:
        if field not in chunk:
            return False
    
    # Validate chunk_id format (doc_id:page:reading_order:part)
    chunk_id = chunk.get("chunk_id", "")
    if not chunk_id or chunk_id.count(":") != 3:
        return False
    
    # Validate grounding structure
    grounding = chunk.get("grounding", [])
    if not isinstance(grounding, list) or not grounding:
        return False
    
    for ground in grounding:
        if not isinstance(ground, dict) or "page" not in ground:
            return False
    
    # Validate basic metadata structure
    metadata = chunk.get("metadata", {})
    if not isinstance(metadata, dict):
        return False
    
    return True


def get_chunk_summary(chunk: PhilatelicChunk) -> Dict[str, Any]:
    """
    Generate a summary of chunk content and metadata.
    
    Args:
        chunk: A complete philatelic chunk
        
    Returns:
        Dictionary with summary information
        
    Example:
        >>> summary = get_chunk_summary(chunk)
        >>> print(summary)
        {
            "chunk_id": "OXCART30:005:12-12:0",
            "type": "text",
            "text_length": 67,
            "page": 5,
            "has_bbox": true,
            "catalog_systems": ["Scott"],
            "topics": ["definitive"],
            "quality_score": 0.85
        }
    """
    entities = chunk.get("metadata", {}).get("entities", {})
    topics = chunk.get("metadata", {}).get("topics", {})
    grounding = chunk.get("grounding", [])
    
    # Extract catalog systems
    catalog_systems = []
    if entities.get("catalog"):
        catalog_systems = list(set(cat["system"] for cat in entities["catalog"]))
    
    # Extract topic information
    topic_list = []
    if topics.get("primary"):
        topic_list.append(topics["primary"])
    topic_list.extend(topics.get("secondary", []))
    
    summary = {
        "chunk_id": chunk.get("chunk_id"),
        "type": chunk.get("chunk_type"),
        "text_length": len(chunk.get("text", "")),
        "page": grounding[0].get("page") if grounding else None,
        "has_bbox": bool(grounding and grounding[0].get("box")),
        "catalog_systems": catalog_systems,
        "topics": topic_list,
        "quality_score": chunk.get("metadata", {}).get("quality_score", 0.0)
    }
    
    return summary


def extract_all_catalog_numbers(document: PhilatelicDocument) -> List[CatalogEntry]:
    """
    Extract all catalog numbers from a document.
    
    Args:
        document: Complete philatelic document
        
    Returns:
        List of all unique catalog entries found in the document
        
    Example:
        >>> catalogs = extract_all_catalog_numbers(doc)
        >>> print(catalogs)
        [
            {"system": "Scott", "number": "147"},
            {"system": "Scott", "number": "148-152"},
            {"system": "Michel", "number": "23a"}
        ]
    """
    all_catalogs = []
    
    for chunk in document.get("chunks", []):
        entities = chunk.get("metadata", {}).get("entities", {})
        catalogs = entities.get("catalog", [])
        all_catalogs.extend(catalogs)
    
    # Remove duplicates while preserving order
    seen = set()
    unique_catalogs = []
    for cat in all_catalogs:
        key = (cat["system"], cat["number"])
        if key not in seen:
            seen.add(key)
            unique_catalogs.append(cat)
    
    return unique_catalogs


# ============================================================================
# EXAMPLE USAGE AND DOCUMENTATION
# ============================================================================

if __name__ == "__main__":
    """
    Example usage and demonstrations of the philatelic chunk schema.
    """
    
    # Example 1: Basic chunk structure
    example_chunk: PhilatelicChunk = {
        "chunk_id": "OXCART30:005:12-12:0",
        "chunk_type": "text",
        "text": "Scott 147, 5 centavos blue, mint never hinged, very fine centering. This stamp shows the coat of arms design and was printed by lithography on wove paper.",
        "grounding": [{
            "page": 5,
            "box": {
                "l": 0.123,
                "t": 0.456, 
                "r": 0.789,
                "b": 0.890
            }
        }],
        "metadata": {
            "labels": ["para"],
            "reading_order_range": [12, 12],
            "part_index": None,
            "quality_score": 0.85,
            "entities": {
                "catalog": [{"system": "Scott", "number": "147"}],
                "values": [{"face_value": 5.0, "unit": "centavos"}],
                "colors": ["blue"],
                "designs": ["coat of arms"],
                "printing": {"method": "lithographed"},
                "paper": {"type": "wove paper"},
                "condition": {
                    "mint_status": "mint never hinged",
                    "centering": "very fine"
                }
            },
            "topics": {
                "primary": "definitive",
                "secondary": [],
                "tags": [],
                "confidence": 0.85
            }
        }
    }
    
    # Example 2: Table chunk with complex structure
    table_chunk: PhilatelicChunk = {
        "chunk_id": "OXCART30:008:15-15:0", 
        "chunk_type": "table",
        "text": "| Scott | Value | Color |\n|-------|-------|-------|\n| 147 | 5c | blue |\n| 148 | 10c | red |",
        "grounding": [{
            "page": 8,
            "box": {"l": 0.1, "t": 0.3, "r": 0.9, "b": 0.7}
        }],
        "metadata": {
            "labels": ["tab"],
            "reading_order_range": [15, 15],
            "quality_score": 0.75,
            "table_markdown": "| Scott | Value | Color |\n|-------|-------|-------|\n| 147 | 5c | blue |\n| 148 | 10c | red |",
            "headers": ["Scott", "Value", "Color"],
            "n_rows": 2,
            "entities": {
                "catalog": [
                    {"system": "Scott", "number": "147"},
                    {"system": "Scott", "number": "148"}
                ],
                "values": [
                    {"face_value": 5.0, "unit": "c"},
                    {"face_value": 10.0, "unit": "c"}
                ],
                "colors": ["blue", "red"]
            },
            "topics": {
                "primary": "definitive",
                "confidence": 0.75
            }
        }
    }
    
    # Example 3: EFO variety chunk
    efo_chunk: PhilatelicChunk = {
        "chunk_id": "OXCART30:012:8-8:0",
        "chunk_type": "text", 
        "text": "Scott 25 with inverted GUANACASTE overprint, extremely rare variety with only 3 copies known.",
        "grounding": [{"page": 12, "box": {"l": 0.2, "t": 0.4, "r": 0.8, "b": 0.5}}],
        "metadata": {
            "labels": ["para"],
            "reading_order_range": [8, 8],
            "quality_score": 0.95,
            "entities": {
                "catalog": [{"system": "Scott", "number": "25"}],
                "varieties": [{
                    "class": "overprint",
                    "subtype": "inverted",
                    "label": "sobrecarga invertida",
                    "text": "GUANACASTE",
                    "confidence": 0.9
                }],
                "costa_rica_context": {
                    "guanacaste_period": True,
                    "historical_significance": "1885-1891 Guanacaste overprint period"
                }
            },
            "topics": {
                "primary": "overprint",
                "secondary": ["varieties"],
                "tags": ["error", "variety"],
                "confidence": 0.95
            }
        }
    }
    
    # Demonstrate validation
    print("Validating example chunks:")
    print(f"Basic chunk valid: {validate_chunk_structure(example_chunk)}")
    print(f"Table chunk valid: {validate_chunk_structure(table_chunk)}")
    print(f"EFO chunk valid: {validate_chunk_structure(efo_chunk)}")
    
    # Demonstrate summary generation
    print(f"\nBasic chunk summary: {get_chunk_summary(example_chunk)}")
    print(f"EFO chunk summary: {get_chunk_summary(efo_chunk)}")
    
    print("\nPhilatelic Chunk Schema loaded successfully!")
    print("All type definitions and examples are available for use.")