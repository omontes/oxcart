"""
Test Suite for Bilingual Philatelic System

This script validates the enhanced bilingual capabilities of the philatelic
chunk enrichment system, testing pattern recognition in both English and Spanish.

VERSION: 1.0 - Bilingual Testing Suite
AUTHOR: Generated by Claude Code for OXCART RAG Project
LAST UPDATE: 2025-08-26
"""

import sys
import os
from typing import Dict, List, Any
import json

# Add current directory to Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from philatelic_chunk_logic import (
    SemanticEnricher,
    BilingualPatterns,
    CatalogExtractor,
    EFOClassifier,
    TechnicalSpecsExtractor,
    ConditionAssessor,
    CostaRicaContextExtractor
)


class BilingualPhilatelicTester:
    """Comprehensive test suite for bilingual philatelic system."""
    
    def __init__(self):
        self.enricher = SemanticEnricher()
        self.patterns = BilingualPatterns()
        self.test_results = []
    
    def create_test_chunk(self, chunk_id: str, text: str) -> Dict[str, Any]:
        """Create a test chunk structure."""
        return {
            "chunk_id": chunk_id,
            "chunk_type": "text",
            "text": text,
            "grounding": [{"page": 1, "box": {"l": 0.1, "t": 0.1, "r": 0.9, "b": 0.2}}],
            "metadata": {}
        }
    
    def test_catalog_extraction(self):
        """Test catalog number extraction in both languages."""
        print("\n" + "="*60)
        print("TEST 1: CATALOG EXTRACTION (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # English cases
            ("Scott 147, Michel 23a, Yvert 45", ["Scott 147", "Michel 23a", "Yvert 45"]),
            ("SG 125, Gibbons No. 126", ["Gibbons 125", "Gibbons 126"]),
            ("Sc. 45-50, Mi. 23b", ["Scott 45-50", "Michel 23b"]),
            
            # Spanish cases with international catalogs
            ("Catálogo Scott 147, Michel 23a", ["Scott 147", "Michel 23a"]),
            
            # Costa Rica specific
            ("GR20, CR47, A21", ["CR_GR GR20", "CR_GR CR47", "Legacy_A A21"]),
            ("Guanacaste G3, sobrecarga tipo GR15", ["CR_GR G3", "CR_GR GR15"]),
        ]
        
        extractor = CatalogExtractor(self.patterns)
        
        for i, (text, expected_count) in enumerate(test_cases):
            catalogs = extractor.extract_catalog_numbers(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Extracted: {catalogs}")
            print(f"Expected count: {len(expected_count)}, Got: {len(catalogs)}")
            
            # Validate extraction
            success = len(catalogs) >= len(expected_count) * 0.7  # 70% success rate
            status = "✅ PASS" if success else "❌ FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "catalog_extraction",
                "case": i+1,
                "success": success,
                "expected": len(expected_count),
                "actual": len(catalogs)
            })
    
    def test_efo_classification(self):
        """Test EFO classification in both languages."""
        print("\n" + "="*60)
        print("TEST 2: EFO CLASSIFICATION (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # Spanish EFO terms
            ("sobrecarga GUANACASTE invertida", "sobrecarga invertida"),
            ("error de color azul", "error de color"),
            ("centro invertido muy raro", "centro invertido"),
            ("impresión espejo única", "impresión espejo"),
            ("sobrecarga doble en rojo", "sobrecarga doble"),
            
            # English EFO terms
            ("inverted overprint GUANACASTE", "sobrecarga invertida"),
            ("missing color variety", "color omitido"),
            ("color error on stamp", "error de color"),
            ("double overprint error", "sobrecarga doble"),
            ("mirror print variety", "impresión espejo"),
        ]
        
        classifier = EFOClassifier(self.patterns)
        
        for i, (text, expected_label) in enumerate(test_cases):
            varieties = classifier.classify_efo_varieties(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Expected label: {expected_label}")
            
            if varieties:
                print(f"Found varieties: {[v['label'] for v in varieties]}")
                found_expected = any(expected_label in v['label'] for v in varieties)
                status = "✅ PASS" if found_expected else "❌ FAIL" 
            else:
                print("No varieties found")
                status = "❌ FAIL"
            
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "efo_classification",
                "case": i+1,
                "success": status == "✅ PASS",
                "expected": expected_label,
                "actual": [v['label'] for v in varieties] if varieties else []
            })
    
    def test_technical_specifications(self):
        """Test technical specifications extraction."""
        print("\n" + "="*60)
        print("TEST 3: TECHNICAL SPECIFICATIONS (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # Perforation - Spanish
            ("dentado 12, sin dentar", {"perforation": True}),
            ("perforación de peine 11.5x12", {"perforation": True}),
            
            # Perforation - English  
            ("perf 12, imperforate variety", {"perforation": True}),
            ("comb perf 11.5, line perf", {"perforation": True}),
            
            # Paper - Spanish
            ("papel satinado grueso", {"paper": True}),
            ("papel vergé delgado", {"paper": True}),
            
            # Paper - English
            ("wove paper thick", {"paper": True}),
            ("laid paper, granite paper", {"paper": True}),
            
            # Printing - Mixed
            ("litografía, lithographed", {"printing": True}),
            ("calcografía, engraved", {"printing": True}),
        ]
        
        extractor = TechnicalSpecsExtractor(self.patterns)
        
        for i, (text, expected_specs) in enumerate(test_cases):
            specs = extractor.extract_technical_specifications(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Extracted specs: {list(specs.keys())}")
            
            # Check if expected specifications were found
            success = all(spec_type in specs for spec_type in expected_specs.keys())
            status = "✅ PASS" if success else "❌ FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "technical_specifications",
                "case": i+1,
                "success": success,
                "expected": list(expected_specs.keys()),
                "actual": list(specs.keys())
            })
    
    def test_condition_assessment(self):
        """Test condition assessment in both languages."""
        print("\n" + "="*60)
        print("TEST 4: CONDITION ASSESSMENT (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # Spanish conditions
            ("nuevo sin charnela, muy fino", {"mint_status", "centering"}),
            ("usado, con arruga y mancha", {"used_status", "defects"}),
            ("matasellado primer día", {"used_status"}),
            
            # English conditions
            ("mint never hinged, extremely fine", {"mint_status", "centering"}),
            ("used, with tear and stain", {"used_status", "defects"}),
            ("first day cancel, very fine", {"used_status", "centering"}),
        ]
        
        assessor = ConditionAssessor(self.patterns)
        
        for i, (text, expected_fields) in enumerate(test_cases):
            condition = assessor.extract_condition_assessment(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Condition fields: {list(condition.keys())}")
            
            # Check if expected condition fields were found
            found_fields = set(condition.keys())
            success = len(expected_fields.intersection(found_fields)) >= 1
            status = "✅ PASS" if success else "❌ FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "condition_assessment", 
                "case": i+1,
                "success": success,
                "expected": list(expected_fields),
                "actual": list(condition.keys())
            })
    
    def test_costa_rica_context(self):
        """Test Costa Rica specific context extraction."""
        print("\n" + "="*60)
        print("TEST 5: COSTA RICA CONTEXT")
        print("="*60)
        
        test_cases = [
            ("sobreimpresiones de Guanacaste 1885-1891", {"guanacaste_period"}),
            ("decreto CXIX de 1885", {"guanacaste_period"}),
            ("Jesús Jiménez, período colonial", {"personalities", "historical_periods"}),
            ("Volcán Arenal, Puerto Limón", {"geographic_features"}),
        ]
        
        extractor = CostaRicaContextExtractor(self.patterns)
        
        for i, (text, expected_fields) in enumerate(test_cases):
            context = extractor.extract_costa_rica_context(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Context fields: {list(context.keys())}")
            
            # Check if expected context fields were found  
            found_fields = set(context.keys())
            success = len(expected_fields.intersection(found_fields)) >= 1
            status = "✅ PASS" if success else "❌ FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "costa_rica_context",
                "case": i+1, 
                "success": success,
                "expected": list(expected_fields),
                "actual": list(context.keys())
            })
    
    def test_full_enrichment(self):
        """Test full chunk enrichment with bilingual examples."""
        print("\n" + "="*60)
        print("TEST 6: FULL ENRICHMENT (COMPREHENSIVE)")
        print("="*60)
        
        # Complex Spanish example
        chunk_es = self.create_test_chunk(
            "TEST:ES:1",
            "Scott 147, 5 centavos azul, nuevo sin charnela, muy fino centrado. " +
            "Sobrecarga GUANACASTE invertida, extremadamente raro. " +
            "Litografiado en papel satinado, dentado 12, goma original."
        )
        
        # Complex English example
        chunk_en = self.create_test_chunk(
            "TEST:EN:1", 
            "Michel 23a, 10c red, mint never hinged, very fine centering. " +
            "Double overprint variety, signed Peralta. " +
            "Engraved on wove paper, perf 11.5x12, original gum."
        )
        
        test_chunks = [
            ("Spanish", chunk_es),
            ("English", chunk_en)
        ]
        
        for lang, chunk in test_chunks:
            print(f"\n{lang.upper()} ENRICHMENT TEST:")
            print(f"Original: {chunk['text']}")
            
            enriched = self.enricher.enrich_chunk_advanced_bilingual(chunk)
            entities = enriched.get('metadata', {}).get('entities', {})
            quality_score = enriched.get('metadata', {}).get('quality_score', 0)
            
            print(f"Quality score: {quality_score:.2f}")
            print(f"Entities found: {list(entities.keys())}")
            
            # Validate comprehensive enrichment
            expected_entities = {'catalog', 'condition', 'colors'}
            found_entities = set(entities.keys())
            success = len(expected_entities.intersection(found_entities)) >= 2
            status = "✅ PASS" if success else "❌ FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "full_enrichment",
                "language": lang,
                "success": success,
                "quality_score": quality_score,
                "entities_count": len(entities)
            })
    
    def generate_test_report(self):
        """Generate comprehensive test report."""
        print("\n" + "="*80)
        print("BILINGUAL PHILATELIC SYSTEM - TEST REPORT")
        print("="*80)
        
        # Count results by test type
        test_stats = {}
        for result in self.test_results:
            test_type = result['test']
            if test_type not in test_stats:
                test_stats[test_type] = {'passed': 0, 'total': 0}
            
            test_stats[test_type]['total'] += 1
            if result['success']:
                test_stats[test_type]['passed'] += 1
        
        # Print detailed results
        overall_passed = 0
        overall_total = 0
        
        for test_type, stats in test_stats.items():
            passed = stats['passed']
            total = stats['total']
            percentage = (passed / total) * 100
            
            print(f"\n{test_type.upper().replace('_', ' ')}:")
            print(f"  Passed: {passed}/{total} ({percentage:.1f}%)")
            
            overall_passed += passed
            overall_total += total
        
        # Overall results
        overall_percentage = (overall_passed / overall_total) * 100
        print(f"\nOVERALL RESULTS:")
        print(f"  Total tests: {overall_total}")
        print(f"  Passed: {overall_passed}")
        print(f"  Success rate: {overall_percentage:.1f}%")
        
        # Success criteria
        if overall_percentage >= 80:
            print(f"\n✅ SYSTEM STATUS: EXCELLENT")
            print("The bilingual philatelic system is working excellently!")
        elif overall_percentage >= 60:
            print(f"\n⚠️ SYSTEM STATUS: GOOD") 
            print("The system is working well with minor issues.")
        else:
            print(f"\n❌ SYSTEM STATUS: NEEDS IMPROVEMENT")
            print("The system requires debugging and improvement.")
        
        print("\n" + "="*80)
        
        return {
            'overall_percentage': overall_percentage,
            'test_stats': test_stats,
            'total_tests': overall_total,
            'passed_tests': overall_passed
        }
    
    def run_all_tests(self):
        """Run all test suites."""
        print("🚀 Starting Bilingual Philatelic System Tests")
        print("Testing enhanced patterns with English/Spanish support")
        
        self.test_catalog_extraction()
        self.test_efo_classification()
        self.test_technical_specifications()
        self.test_condition_assessment()
        self.test_costa_rica_context()
        self.test_full_enrichment()
        
        return self.generate_test_report()


# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    """Run the complete bilingual test suite."""
    
    print("Bilingual Philatelic System - Comprehensive Test Suite")
    print("Version 1.0 - Testing English/Spanish pattern recognition")
    print("="*80)
    
    try:
        tester = BilingualPhilatelicTester()
        results = tester.run_all_tests()
        
        # Save results to JSON
        with open('bilingual_test_results.json', 'w', encoding='utf-8') as f:
            json.dump({
                'timestamp': '2025-08-26',
                'version': '1.0',
                'summary': results,
                'detailed_results': tester.test_results
            }, f, indent=2, ensure_ascii=False)
        
        print(f"\n📄 Detailed results saved to: bilingual_test_results.json")
        
    except Exception as e:
        print(f"\n❌ ERROR during testing: {str(e)}")
        import traceback
        traceback.print_exc()
    
    print("\n🎯 Testing complete!")