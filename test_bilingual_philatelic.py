"""
Test Suite for Bilingual Philatelic System

This script validates the enhanced bilingual capabilities of the philatelic
chunk enrichment system, testing pattern recognition in both English and Spanish.

VERSION: 1.0 - Bilingual Testing Suite
AUTHOR: Generated by Claude Code for OXCART RAG Project
LAST UPDATE: 2025-08-26
"""

import sys
import os
from typing import Dict, List, Any
import json

# Add current directory to Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from philatelic_chunk_logic import (
    SemanticEnricher,
    BilingualPatterns,
    CatalogExtractor,
    EFOClassifier,
    TechnicalSpecsExtractor,
    ConditionAssessor,
    CostaRicaContextExtractor
)


class BilingualPhilatelicTester:
    """Comprehensive test suite for bilingual philatelic system."""
    
    def __init__(self):
        self.enricher = SemanticEnricher()
        self.patterns = BilingualPatterns()
        self.test_results = []
    
    def create_test_chunk(self, chunk_id: str, text: str) -> Dict[str, Any]:
        """Create a test chunk structure."""
        return {
            "chunk_id": chunk_id,
            "chunk_type": "text",
            "text": text,
            "grounding": [{"page": 1, "box": {"l": 0.1, "t": 0.1, "r": 0.9, "b": 0.2}}],
            "metadata": {}
        }
    
    def test_catalog_extraction(self):
        """Test catalog number extraction in both languages."""
        print("\n" + "="*60)
        print("TEST 1: CATALOG EXTRACTION (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # English cases
            ("Scott 147, Michel 23a, Yvert 45", ["Scott 147", "Michel 23a", "Yvert 45"]),
            ("SG 125, Gibbons No. 126", ["Gibbons 125", "Gibbons 126"]),
            ("Sc. 45-50, Mi. 23b", ["Scott 45-50", "Michel 23b"]),
            
            # Spanish cases with international catalogs
            ("Cat√°logo Scott 147, Michel 23a", ["Scott 147", "Michel 23a"]),
            
            # Costa Rica specific
            ("GR20, CR47, A21", ["CR_GR GR20", "CR_GR CR47", "Legacy_A A21"]),
            ("Guanacaste G3, sobrecarga tipo GR15", ["CR_GR G3", "CR_GR GR15"]),
        ]
        
        extractor = CatalogExtractor(self.patterns)
        
        for i, (text, expected_count) in enumerate(test_cases):
            catalogs = extractor.extract_catalog_numbers(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Extracted: {catalogs}")
            print(f"Expected count: {len(expected_count)}, Got: {len(catalogs)}")
            
            # Validate extraction
            success = len(catalogs) >= len(expected_count) * 0.7  # 70% success rate
            status = "‚úÖ PASS" if success else "‚ùå FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "catalog_extraction",
                "case": i+1,
                "success": success,
                "expected": len(expected_count),
                "actual": len(catalogs)
            })
    
    def test_efo_classification(self):
        """Test EFO classification in both languages."""
        print("\n" + "="*60)
        print("TEST 2: EFO CLASSIFICATION (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # Spanish EFO terms
            ("sobrecarga GUANACASTE invertida", "sobrecarga invertida"),
            ("error de color azul", "error de color"),
            ("centro invertido muy raro", "centro invertido"),
            ("impresi√≥n espejo √∫nica", "impresi√≥n espejo"),
            ("sobrecarga doble en rojo", "sobrecarga doble"),
            
            # English EFO terms
            ("inverted overprint GUANACASTE", "sobrecarga invertida"),
            ("missing color variety", "color omitido"),
            ("color error on stamp", "error de color"),
            ("double overprint error", "sobrecarga doble"),
            ("mirror print variety", "impresi√≥n espejo"),
        ]
        
        classifier = EFOClassifier(self.patterns)
        
        for i, (text, expected_label) in enumerate(test_cases):
            varieties = classifier.classify_efo_varieties(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Expected label: {expected_label}")
            
            if varieties:
                print(f"Found varieties: {[v['label'] for v in varieties]}")
                found_expected = any(expected_label in v['label'] for v in varieties)
                status = "‚úÖ PASS" if found_expected else "‚ùå FAIL" 
            else:
                print("No varieties found")
                status = "‚ùå FAIL"
            
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "efo_classification",
                "case": i+1,
                "success": status == "‚úÖ PASS",
                "expected": expected_label,
                "actual": [v['label'] for v in varieties] if varieties else []
            })
    
    def test_technical_specifications(self):
        """Test technical specifications extraction."""
        print("\n" + "="*60)
        print("TEST 3: TECHNICAL SPECIFICATIONS (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # Perforation - Spanish
            ("dentado 12, sin dentar", {"perforation": True}),
            ("perforaci√≥n de peine 11.5x12", {"perforation": True}),
            
            # Perforation - English  
            ("perf 12, imperforate variety", {"perforation": True}),
            ("comb perf 11.5, line perf", {"perforation": True}),
            
            # Paper - Spanish
            ("papel satinado grueso", {"paper": True}),
            ("papel verg√© delgado", {"paper": True}),
            
            # Paper - English
            ("wove paper thick", {"paper": True}),
            ("laid paper, granite paper", {"paper": True}),
            
            # Printing - Mixed
            ("litograf√≠a, lithographed", {"printing": True}),
            ("calcograf√≠a, engraved", {"printing": True}),
        ]
        
        extractor = TechnicalSpecsExtractor(self.patterns)
        
        for i, (text, expected_specs) in enumerate(test_cases):
            specs = extractor.extract_technical_specifications(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Extracted specs: {list(specs.keys())}")
            
            # Check if expected specifications were found
            success = all(spec_type in specs for spec_type in expected_specs.keys())
            status = "‚úÖ PASS" if success else "‚ùå FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "technical_specifications",
                "case": i+1,
                "success": success,
                "expected": list(expected_specs.keys()),
                "actual": list(specs.keys())
            })
    
    def test_condition_assessment(self):
        """Test condition assessment in both languages."""
        print("\n" + "="*60)
        print("TEST 4: CONDITION ASSESSMENT (BILINGUAL)")
        print("="*60)
        
        test_cases = [
            # Spanish conditions
            ("nuevo sin charnela, muy fino", {"mint_status", "centering"}),
            ("usado, con arruga y mancha", {"used_status", "defects"}),
            ("matasellado primer d√≠a", {"used_status"}),
            
            # English conditions
            ("mint never hinged, extremely fine", {"mint_status", "centering"}),
            ("used, with tear and stain", {"used_status", "defects"}),
            ("first day cancel, very fine", {"used_status", "centering"}),
        ]
        
        assessor = ConditionAssessor(self.patterns)
        
        for i, (text, expected_fields) in enumerate(test_cases):
            condition = assessor.extract_condition_assessment(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Condition fields: {list(condition.keys())}")
            
            # Check if expected condition fields were found
            found_fields = set(condition.keys())
            success = len(expected_fields.intersection(found_fields)) >= 1
            status = "‚úÖ PASS" if success else "‚ùå FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "condition_assessment", 
                "case": i+1,
                "success": success,
                "expected": list(expected_fields),
                "actual": list(condition.keys())
            })
    
    def test_costa_rica_context(self):
        """Test Costa Rica specific context extraction."""
        print("\n" + "="*60)
        print("TEST 5: COSTA RICA CONTEXT")
        print("="*60)
        
        test_cases = [
            ("sobreimpresiones de Guanacaste 1885-1891", {"guanacaste_period"}),
            ("decreto CXIX de 1885", {"guanacaste_period"}),
            ("Jes√∫s Jim√©nez, per√≠odo colonial", {"personalities", "historical_periods"}),
            ("Volc√°n Arenal, Puerto Lim√≥n", {"geographic_features"}),
        ]
        
        extractor = CostaRicaContextExtractor(self.patterns)
        
        for i, (text, expected_fields) in enumerate(test_cases):
            context = extractor.extract_costa_rica_context(text)
            
            print(f"\nTest {i+1}: {text}")
            print(f"Context fields: {list(context.keys())}")
            
            # Check if expected context fields were found  
            found_fields = set(context.keys())
            success = len(expected_fields.intersection(found_fields)) >= 1
            status = "‚úÖ PASS" if success else "‚ùå FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "costa_rica_context",
                "case": i+1, 
                "success": success,
                "expected": list(expected_fields),
                "actual": list(context.keys())
            })
    
    def test_full_enrichment(self):
        """Test full chunk enrichment with bilingual examples."""
        print("\n" + "="*60)
        print("TEST 6: FULL ENRICHMENT (COMPREHENSIVE)")
        print("="*60)
        
        # Complex Spanish example
        chunk_es = self.create_test_chunk(
            "TEST:ES:1",
            "Scott 147, 5 centavos azul, nuevo sin charnela, muy fino centrado. " +
            "Sobrecarga GUANACASTE invertida, extremadamente raro. " +
            "Litografiado en papel satinado, dentado 12, goma original."
        )
        
        # Complex English example
        chunk_en = self.create_test_chunk(
            "TEST:EN:1", 
            "Michel 23a, 10c red, mint never hinged, very fine centering. " +
            "Double overprint variety, signed Peralta. " +
            "Engraved on wove paper, perf 11.5x12, original gum."
        )
        
        test_chunks = [
            ("Spanish", chunk_es),
            ("English", chunk_en)
        ]
        
        for lang, chunk in test_chunks:
            print(f"\n{lang.upper()} ENRICHMENT TEST:")
            print(f"Original: {chunk['text']}")
            
            enriched = self.enricher.enrich_chunk_advanced_bilingual(chunk)
            entities = enriched.get('metadata', {}).get('entities', {})
            quality_score = enriched.get('metadata', {}).get('quality_score', 0)
            
            print(f"Quality score: {quality_score:.2f}")
            print(f"Entities found: {list(entities.keys())}")
            
            # Validate comprehensive enrichment
            expected_entities = {'catalog', 'condition', 'colors'}
            found_entities = set(entities.keys())
            success = len(expected_entities.intersection(found_entities)) >= 2
            status = "‚úÖ PASS" if success else "‚ùå FAIL"
            print(f"Status: {status}")
            
            self.test_results.append({
                "test": "full_enrichment",
                "language": lang,
                "success": success,
                "quality_score": quality_score,
                "entities_count": len(entities)
            })
    
    def generate_test_report(self):
        """Generate comprehensive test report."""
        print("\n" + "="*80)
        print("BILINGUAL PHILATELIC SYSTEM - TEST REPORT")
        print("="*80)
        
        # Count results by test type
        test_stats = {}
        for result in self.test_results:
            test_type = result['test']
            if test_type not in test_stats:
                test_stats[test_type] = {'passed': 0, 'total': 0}
            
            test_stats[test_type]['total'] += 1
            if result['success']:
                test_stats[test_type]['passed'] += 1
        
        # Print detailed results
        overall_passed = 0
        overall_total = 0
        
        for test_type, stats in test_stats.items():
            passed = stats['passed']
            total = stats['total']
            percentage = (passed / total) * 100
            
            print(f"\n{test_type.upper().replace('_', ' ')}:")
            print(f"  Passed: {passed}/{total} ({percentage:.1f}%)")
            
            overall_passed += passed
            overall_total += total
        
        # Overall results
        overall_percentage = (overall_passed / overall_total) * 100
        print(f"\nOVERALL RESULTS:")
        print(f"  Total tests: {overall_total}")
        print(f"  Passed: {overall_passed}")
        print(f"  Success rate: {overall_percentage:.1f}%")
        
        # Success criteria
        if overall_percentage >= 80:
            print(f"\n‚úÖ SYSTEM STATUS: EXCELLENT")
            print("The bilingual philatelic system is working excellently!")
        elif overall_percentage >= 60:
            print(f"\n‚ö†Ô∏è SYSTEM STATUS: GOOD") 
            print("The system is working well with minor issues.")
        else:
            print(f"\n‚ùå SYSTEM STATUS: NEEDS IMPROVEMENT")
            print("The system requires debugging and improvement.")
        
        print("\n" + "="*80)
        
        return {
            'overall_percentage': overall_percentage,
            'test_stats': test_stats,
            'total_tests': overall_total,
            'passed_tests': overall_passed
        }
    
    def run_all_tests(self):
        """Run all test suites."""
        print("üöÄ Starting Bilingual Philatelic System Tests")
        print("Testing enhanced patterns with English/Spanish support")
        
        self.test_catalog_extraction()
        self.test_efo_classification()
        self.test_technical_specifications()
        self.test_condition_assessment()
        self.test_costa_rica_context()
        self.test_full_enrichment()
        
        return self.generate_test_report()


# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    """Run the complete bilingual test suite."""
    
    print("Bilingual Philatelic System - Comprehensive Test Suite")
    print("Version 1.0 - Testing English/Spanish pattern recognition")
    print("="*80)
    
    try:
        tester = BilingualPhilatelicTester()
        results = tester.run_all_tests()
        
        # Save results to JSON
        with open('bilingual_test_results.json', 'w', encoding='utf-8') as f:
            json.dump({
                'timestamp': '2025-08-26',
                'version': '1.0',
                'summary': results,
                'detailed_results': tester.test_results
            }, f, indent=2, ensure_ascii=False)
        
        print(f"\nüìÑ Detailed results saved to: bilingual_test_results.json")
        
    except Exception as e:
        print(f"\n‚ùå ERROR during testing: {str(e)}")
        import traceback
        traceback.print_exc()
    
    print("\nüéØ Testing complete!")